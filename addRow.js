const Excel = require("exceljs");
const readline = require("readline");

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

// –°–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≤—Ä–µ–º—ë–Ω
const availableTimes = [
  "9:35","10:30","9:50","9:35","10:00","11:00","11:20",
  "10:00","9:50","10:00","11:00","9:20","9:50","9:20",
  "10:00","9:30","10:30","11:30","12:30","9:30","11:30","10:20"
];

// –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –¥–∞—Ç—ã –¥–ª—è ExcelJS
function parseDate(value) {
  if (!value) return null;

  if (value instanceof Date) return value;

  if (typeof value === "object") {
    if (value.text) value = value.text;
    else if (value.richText && value.richText.length > 0) {
      value = value.richText.map(t => t.text).join("");
    } else return null;
  }

  if (typeof value === "number") {
    return new Date(Math.round((value - 25569) * 86400 * 1000));
  }

  if (typeof value === "string") {
    const parts = value.split(".");
    if (parts.length !== 3) return null;
    return new Date(parts[2], parts[1] - 1, parts[0]);
  }

  return null;
}

// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞—Ç—ã
function formatDate(date) {
  const dd = String(date.getDate()).padStart(2,"0");
  const mm = String(date.getMonth()+1).padStart(2,"0");
  const yyyy = date.getFullYear();
  return `${dd}.${mm}.${yyyy}`;
}

// –ù–∞–π—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç—Ä–æ–∫—É —Å —Ç–µ–∫—Å—Ç–æ–º –≤ –∫–æ–ª–æ–Ω–∫–∞—Ö 2 –∏ 3
function findLastValidRow(sheet) {
  for (let i = sheet.rowCount; i > 0; i--) {
    const row = sheet.getRow(i);
    if (row.getCell(2).value && row.getCell(3).value) {
      return row;
    }
  }
  return null;
}

async function processFile(targetDate) {
  const fs = require('fs');
  const originalFileName = "–ñ–£–†–ù–ê–õ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è.xlsx";
  const backupFileName = "–ñ–£–†–ù–ê–õ —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è copy.xlsx";
  
  // Create a backup copy of the original file
  try {
    fs.copyFileSync(originalFileName, backupFileName);
    console.log(`üìã Created backup: ${backupFileName}`);
  } catch (error) {
    console.error(`‚ùå Failed to create backup: ${error.message}`);
    return;
  }

  const workbook = new Excel.Workbook();
  await workbook.xlsx.readFile(originalFileName);

  for (let sheetIndex = 0; sheetIndex < 3; sheetIndex++) {
    const sheet = workbook.worksheets[sheetIndex];
    if (!sheet) continue;

    let lastRow = findLastValidRow(sheet);
    if (!lastRow) {
      console.log(`‚ö†Ô∏è Sheet "${sheet.name}" –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å—Ç—Ä–æ–∫ —Å —Ç–µ–∫—Å—Ç–æ–º –≤ –∫–æ–ª–æ–Ω–∫–∞—Ö 2 –∏ 3, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º`);
      continue;
    }

    console.log(`Sheet "${sheet.name}" last valid row:`);
    console.log(`   Row #${lastRow.number}: Column2="${lastRow.getCell(2).value}", Column3="${lastRow.getCell(3).value}"`);

    const useRow = await new Promise(resolve => {
      rl.question("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É —Å—Ç—Ä–æ–∫—É –∫–∞–∫ –±–∞–∑—É –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤—ã—Ö? (y/n): ", ans => {
        resolve(ans.trim().toLowerCase() === "y");
      });
    });

    if (!useRow) {
      console.log(`–ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ª–∏—Å—Ç "${sheet.name}"`);
      continue;
    }

    let lastDate = parseDate(lastRow.getCell(2).value);
    let insertIndex = lastRow.number + 1; // —Å–ª–µ–¥—É—é—â–∞—è —Å—Ç—Ä–æ–∫–∞ –ø–æ—Å–ª–µ –Ω–∞–π–¥–µ–Ω–Ω–æ–π

    while (lastDate < targetDate) {
      const newDate = new Date(lastDate.getTime() + 7*24*60*60*1000);

      // —Å–æ–∑–¥–∞—ë–º –º–∞—Å—Å–∏–≤ –∑–Ω–∞—á–µ–Ω–∏–π
      const newRowValues = lastRow.values.slice();
      newRowValues[2] = formatDate(newDate);
      newRowValues[3] = availableTimes[Math.floor(Math.random() * availableTimes.length)];

      // –≤—Å—Ç–∞–≤–ª—è–µ–º –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É –Ω–∞ –Ω—É–∂–Ω–æ–µ –º–µ—Å—Ç–æ
      sheet.spliceRows(insertIndex, 0, []);

      const newRow = sheet.getRow(insertIndex);

      // –∫–æ–ø–∏—Ä—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –∏ —Å—Ç–∏–ª–∏
      newRowValues.forEach((val, idx) => {
        const cell = newRow.getCell(idx);
        const lastCell = lastRow.getCell(idx);

        cell.value = val;

        // –∫–æ–ø–∏—Ä—É–µ–º —Å—Ç–∏–ª–∏
        cell.font = lastCell.font;
        cell.alignment = lastCell.alignment;
        cell.border = lastCell.border;
        cell.fill = lastCell.fill;
        cell.numFmt = lastCell.numFmt;
      });

      console.log(`   ‚ûï Added styled row at #${insertIndex}: ${newRowValues}`);

      lastRow = newRow;
      lastDate = parseDate(newRow.getCell(2).value);
      insertIndex++;
    }
  }

  await workbook.xlsx.writeFile(originalFileName);
  console.log("‚úÖ File updated successfully!");
  console.log(`üíæ Original backup saved as: ${backupFileName}`);
  rl.close();
}

rl.question("Enter target date (DD.MM.YYYY): ", async (answer) => {
  const targetDate = parseDate(answer.trim());
  if (!targetDate) {
    console.error("‚ùå Invalid date format. Use DD.MM.YYYY");
    rl.close();
    return;
  }
  await processFile(targetDate);
});
